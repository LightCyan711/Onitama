<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Onitama AI - Zen Strategy Game</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Serif+KR:wght@400;700;900&family=Outfit:wght@300;400;600&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="style.css">
    <!-- ONNX Runtime Web -->
    <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js"></script>
    <style>
        .onnx-badge {
            background-color: #6f42c1;
            color: white;
            padding: 5px 10px;
            border-radius: 15px;
            font-size: 0.8em;
            vertical-align: middle;
            margin-left: 10px;
        }
        #loading-overlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 1.5em;
            z-index: 1000;
        }
        .hidden { display: none !important; }
    </style>
</head>
<body>
    <button id="btn-guide" title="게임 방법">?</button>

    <div id="game-notice" class="hidden"></div>
    <div id="loading-overlay" class="hidden">
        AI 모델 로딩 중... 🤖
    </div>

    <div class="container">
        <header>
            <h1>🥋 오니타마 AI</h1>
            <p class="subtitle">오류가 발생한다면 새 게임을 눌러 주세요</p> <!-- Updated subtitle -->
        </header>

        <div id="panel-play" class="panel">
            <div class="game-layout">
                <!-- 왼쪽: 보드 영역 -->
                <div class="board-section">
                    <div class="game-area">
                        <canvas id="canvas-play" width="500" height="500"></canvas>
                    </div>
                </div>

                <!-- 오른쪽: 정보 및 컨트롤 영역 -->
                <div class="info-section">
                    <div class="ai-cards-section hidden">
                        <div id="ai-cards" class="player-cards">
                            <div class="card-label">AI 카드</div>
                            <div class="cards-holder"></div>
                        </div>
                    </div>

                    <div class="status-card">
                        <div id="turn-indicator">게임 준비 중...</div>

                        <div class="center-card-wrapper">
                            <div class="card-label">중앙 카드</div>
                            <div id="center-card"></div>
                        </div>
                    </div>

                    <div class="player-cards-section">
                        <div id="player-cards" class="player-cards">
                            <div class="card-label">내 카드 (클릭하여 선택)</div>
                            <div class="cards-holder"></div>
                        </div>
                    </div>

                    <div class="controls-section">
                        <div class="help-text">
                            ⌨️ <strong>f</strong>: 카드 목록 토글<br>
                            1️⃣ 카드 선택 → 2️⃣ 말 선택 → 3️⃣ 이동
                        </div>
                        <button id="btn-new-game" class="btn btn-primary">🎲 새 게임 시작</button>
                    </div>
                </div>
            </div>
        </div>

    </div>

    <div id="card-encyclopedia" class="hidden">
        <h2>카드 도감</h2>
        <div id="card-list"></div>
        <button id="close-encyclopedia" class="btn btn-secondary">닫기</button>
    </div>

    <!-- 게임 가이드 모달 -->
    <div id="modal-guide" class="modal">
        <div class="modal-content">
            <button id="btn-close-modal">&times;</button>
            <h2>🥋 오니타마 게임 가이드</h2>
            <div class="guide-text">
                <h3>1. 게임 개요</h3>
                <p>오니타마는 5x5 보드에서 펼쳐지는 2인용 전략 보드게임입니다. 각 플레이어는 1명의 마스터와 4명의 제자를 조종합니다.</p>
                
                <h3>2. 승리 조건</h3>
                <ul>
                    <li><strong>돌의 길 (Way of the Stone):</strong> 상대방의 마스터를 잡으면 승리합니다.</li>
                    <li><strong>강의 길 (Way of the Stream):</strong> 내 마스터가 상대방의 사원 입구(중앙 칸)에 도달하면 승리합니다.</li>
                </ul>

                <h3>3. 게임 방법</h3>
                <p>플레이어는 자신에게 주어진 2장의 무술 카드 중 하나를 선택하여 말을 이동시킵니다.</p>
                <ul>
                    <li>카드를 사용한 후에는 그 카드를 <strong>중앙 카드</strong>와 교체합니다.</li>
                    <li>교체된 카드는 다음 턴에 상대방이 사용할 수 있게 됩니다.</li>
                    <li>카드는 계속해서 순환하며 전략적인 선택이 핵심입니다.</li>
                </ul>

                <h3>4. 조작 방법</h3>
                <p>1️⃣ 사용할 카드를 클릭하세요.<br>
                   2️⃣ 이동할 내 말(빨간색)을 클릭하세요.<br>
                   3️⃣ 표시되는 초록색 원 중 하나를 클릭하여 이동하세요.</p>
            </div>
        </div>
    </div>

    <!-- 게임 종료 오버레이 -->
    <div id="game-over-overlay">
        <div id="game-over-title" class="game-over-title"></div>
        <div id="game-over-msg" class="game-over-msg"></div>
        <button id="btn-restart">다시 시작하기</button>
    </div>



    <!-- 순서 중요: 종속성 -->
    <script src="js/cards.js"></script>
    <script src="js/board.js"></script>
    <script src="js/ui.js"></script>
    
    <!-- ONNX Agent -->
    <script src="js/onnx_agent.js"></script>

    <script>
        // Main Logic (Simplified for ONNX only)
        let playUI, playGame, agent;
        let selectedPiece = null;
        let selectedCard = null;
        let possibleMoves = [];

        async function init() {
            const loading = document.getElementById('loading-overlay');
            loading.classList.remove('hidden');

            playUI = new OnitamaUI('canvas-play');
            playGame = new OnitamaGame();
            
            // ONNX Agent 초기화
            agent = new OnitamaOnnxAgent();
            const success = await agent.load('./onitama-actor.onnx'); // 상대 경로로 수정
            
            loading.classList.add('hidden');

            if (!success) {
                alert('모델 로드 실패! index.html(학습버전)으로 이동하거나 경로를 확인하세요.');
                return;
            }

            // 게임 시작
            startNewGame();
            
            // 이벤트 리스너 설정
            setupEventListeners();

            // 카드 도감 초기화
            playUI.setupCardEncyclopedia(getAllCards());
        }

        function startNewGame() {
            playGame.reset();
            selectedPiece = null;
            selectedCard = null;
            possibleMoves = [];
            
            // 종료 화면 숨기기
            document.getElementById('game-over-overlay').classList.remove('show');
            
            updateUI();
            
            // 만약 첫 턴이 AI(Blue, -1)라면 즉시 트리거
            if (playGame.currentPlayer === -1) {
                triggerAITurn();
            }
        }

        function updateUI(aiSelectedCard = null) {
            playUI.drawBoard(playGame);
            playUI.renderCards(playGame, true, selectedCard, aiSelectedCard);
            
            // 턴 인디케이터 텍스트 업데이트
            const indicator = document.getElementById('turn-indicator');
            if (playGame.gameOver) {
                indicator.textContent = "게임 종료";
            } else {
                indicator.textContent = playGame.currentPlayer === 1 ? "당신의 차례입니다 (Red)" : "AI 생각 중... (Blue)";
            }
        }



        function setupEventListeners() {
            document.getElementById('btn-new-game').onclick = startNewGame;
            document.getElementById('btn-restart').onclick = startNewGame;

            // 가이드 모달 열기/닫기
            const guideBtn = document.getElementById('btn-guide');
            const guideModal = document.getElementById('modal-guide');
            const closeModalBtn = document.getElementById('btn-close-modal');

            guideBtn.onclick = () => guideModal.classList.add('show');
            closeModalBtn.onclick = () => guideModal.classList.remove('show');
            window.onclick = (e) => {
                if (e.target === guideModal) guideModal.classList.remove('show');
            };

            // 카드 클릭 (이벤트 위임 방식으로 더 견고하게 변경)
            document.addEventListener('click', (e) => {
                const cardEl = e.target.closest('.card');
                if (!cardEl) return;

                // 내 카드 영역인 경우에만 처리
                if (cardEl.closest('#player-cards')) {
                    if (playGame.gameOver || playGame.currentPlayer !== 1) return;
                    
                    const holder = document.querySelector('#player-cards .cards-holder');
                    const cards = Array.from(holder.querySelectorAll('.card'));
                    const cardIdx = cards.indexOf(cardEl);
                    if (cardIdx !== -1) selectCard(cardIdx);
                }
            });

            // 캔버스 클릭 (보드)
            document.getElementById('canvas-play').onclick = handleBoardClick;
        }

        function selectCard(cardIdx) {
            selectedCard = cardIdx;
            updateUI();
            if (selectedPiece) updatePossibleMoves();
        }


        function handleBoardClick(e) {
            if (playGame.gameOver) return;
            if (playGame.currentPlayer !== 1) return; // AI 턴 방지

            const rect = e.target.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            const pos = playUI.getBoardPosition(x, y);
            
            if (!pos) return;
            const [clickX, clickY] = pos;

            // 내 말 선택
            if (!selectedPiece) {
                const piece = playGame.board[clickY][clickX];
                if (piece > 0) { // Red Piece
                    selectedPiece = [clickX, clickY];
                    playUI.drawBoard(playGame);
                    playUI.drawHighlight(clickX, clickY);
                    if (selectedCard !== null) updatePossibleMoves();
                }
            } else {
                // 이동 시도
                if (selectedCard === null) {
                    playUI.showNotice('먼저 사용할 무술 카드를 선택하십시오.');
                    return;
                }


                const isValidMove = possibleMoves.some(([mx, my]) => mx === clickX && my === clickY);

                if (isValidMove) {
                    executeMove({
                        from: selectedPiece,
                        to: [clickX, clickY],
                        cardIdx: selectedCard
                    });
                } else {
                    // 다른 말 선택 or 취소
                    const piece = playGame.board[clickY][clickX];
                    if (piece > 0) {
                        selectedPiece = [clickX, clickY];
                        updatePossibleMoves();
                    } else {
                        selectedPiece = null;
                        selectedCard = null;
                        possibleMoves = [];
                        updateUI();
                    }
                }
            }
        }

        function updatePossibleMoves() {
            possibleMoves = [];
            if (!selectedPiece || selectedCard === null) return;
            
            const [px, py] = selectedPiece;
            const cardId = playGame.redCards[selectedCard];
            const card = getCard(cardId);
            
            card.moves.forEach(([dx, dy]) => {
                const newX = px + dx;
                const newY = py + dy;
                if (newX >= 0 && newX < 5 && newY >= 0 && newY < 5) {
                    if (playGame.board[newY][newX] <= 0) { // 빈칸(-1) or 적군(-1, -2)
                        possibleMoves.push([newX, newY]);
                    }
                }
            });

            playUI.drawBoard(playGame);
            playUI.drawHighlight(selectedPiece[0], selectedPiece[1]);
            possibleMoves.forEach(([x, y]) => playUI.drawMoveIndicator(x, y));
        }

        async function executeMove(action) {
            playGame.makeMove(action);
            
            // 상태 초기화
            selectedPiece = null;
            selectedCard = null;
            possibleMoves = [];
            updateUI();

            if (checkGameOver()) return;

            // AI 턴 트리거
            await triggerAITurn();
        }

        async function triggerAITurn() {
            if (playGame.gameOver || playGame.currentPlayer !== -1) return;

            // 화면 렌더링을 위해 잠시 대기
            setTimeout(async () => {
                const aiAction = await agent.selectAction(playGame);
                
                if (aiAction) {
                    // AI가 선택한 카드 하이라이트 (시각적 피드백)
                    updateUI(aiAction.cardIdx);
                    
                    // 사용자가 AI의 선택을 인지할 수 있도록 추가 딜레이
                    await new Promise(resolve => setTimeout(resolve, 1200));
                    
                    playGame.makeMove(aiAction);
                    updateUI();
                    checkGameOver();
                } else {
                    alert("AI 기권! 당신의 승리입니다.");
                }
            }, 800);
        }

        function checkGameOver() {
            if (playGame.gameOver) {
                const overlay = document.getElementById('game-over-overlay');
                const titleEl = document.getElementById('game-over-title');
                const msgEl = document.getElementById('game-over-msg');
                
                if (playGame.winner === 1) {
                    titleEl.textContent = "🏆 승리";
                    titleEl.className = "game-over-title victory-title";
                    msgEl.textContent = "훌륭합니다! 전술적인 승리를 거두셨습니다.";
                } else if (playGame.winner === -1) {
                    titleEl.textContent = "😢 패배";
                    titleEl.className = "game-over-title defeat-title";
                    msgEl.textContent = "AI가 당신보다 한 수 앞섰습니다. 다시 도전해보세요!";
                } else {
                    titleEl.textContent = "⚖️ 무승부";
                    titleEl.className = "game-over-title";
                    msgEl.textContent = "승부를 가리지 못했습니다.";
                }
                
                setTimeout(() => {
                    overlay.classList.add('show');
                }, 500);
                return true;
            }
            return false;
        }

        // 시작
        window.onload = init;
    </script>
</body>
</html>
